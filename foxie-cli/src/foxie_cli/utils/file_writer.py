import os
import typer
import subprocess
from foxie_cli.core.models import GeneratedCode
import sys # Needed to find python executable

def unfence_code(code_string: str) -> str:
    """
    Strips the Markdown code fences (```python...```) from a string.
    Handles cases with or without the 'python' language identifier.
    """
    lines = code_string.strip().splitlines()
    if lines and lines[0].strip().startswith("```"):
        if lines[-1].strip() == "```":
            # Remove first and last lines (the fences)
            cleaned_lines = lines[1:-1]
            # If first line was ```python, remove 'python'
            if lines[0].strip().lower() == '```python':
                 pass # No extra adjustment needed after slicing
            return "\n".join(cleaned_lines).strip()
    # If no fences detected or structure is wrong, return original
    return code_string

def format_python_file(file_path: str):
    """Runs the 'black' code formatter using the absolute path."""
    try:
        # Get the absolute path to the python executable running this script
        # This helps ensure black is run from the correct venv
        python_executable = sys.executable
        # Construct the command to run black as a module
        command = [python_executable, "-m", "black", "--quiet", file_path]
        
        result = subprocess.run(
            command,
            check=True,          # Raise error if black fails
            capture_output=True, # Capture stdout and stderr
            text=True,           # Decode output as text
            cwd=os.path.dirname(file_path) # Run from file's directory
        )
        return True
    except subprocess.CalledProcessError as e:
        # Black returned a non-zero exit code. Print stderr.
        error_message = e.stderr.strip() if e.stderr else "No error output from black."
        typer.secho(f"  ‚ùå Black failed for {os.path.basename(file_path)}. Error: {error_message}", fg=typer.colors.RED)
        return False
    except FileNotFoundError:
        # This might happen if 'python' or 'black' module isn't found
        typer.secho(f"  ‚ö†Ô∏è Warning: Could not find Python executable or 'black' module. Skipping formatting for {file_path}.", fg=typer.colors.YELLOW)
        return False
    except Exception as e: # Catch any other unexpected errors
         typer.secho(f"  ‚ùå Unknown error during formatting {os.path.basename(file_path)}: {e}", fg=typer.colors.RED)
         return False

def write_files(generated_code: GeneratedCode, base_dir: str = "."):
    """
    Writes the generated code files, unfencing and formatting them.
    """
    typer.secho("\nüìù Writing generated files to disk...", fg=typer.colors.BLUE)

    if not generated_code.files:
        typer.secho("Warning: No files were generated by the AI.", fg=typer.colors.YELLOW)
        return

    for code_file in generated_code.files:
        # Ensure base_dir exists first
        os.makedirs(base_dir, exist_ok=True)
        
        file_path = os.path.join(base_dir, code_file.file_path)
        directory = os.path.dirname(file_path)

        try:
            if directory:
                os.makedirs(directory, exist_ok=True)

            clean_content = unfence_code(code_file.content)

            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(clean_content)

            typer.secho(f"  ‚úÖ Created: {file_path}", fg=typer.colors.GREEN)

            if file_path.endswith(".py"):
                # Use the absolute path for formatting
                absolute_file_path = os.path.abspath(file_path)
                formatted = format_python_file(absolute_file_path)
                if formatted:
                    typer.secho(f"  ‚ú® Formatted: {os.path.basename(file_path)}", fg=typer.colors.BRIGHT_BLACK)
                else:
                    # Print a warning if formatting failed but file was created
                    typer.secho(f"  ‚ö†Ô∏è Formatting failed for {os.path.basename(file_path)}, file may contain errors.", fg=typer.colors.YELLOW)


        except OSError as e:
            typer.secho(f"  ‚ùå Error creating file {file_path}: {e}", fg=typer.colors.RED)
            # Decide if you want to stop the whole process or just skip this file
            # raise typer.Exit(code=1) 
            typer.secho(f"      Skipping file due to OS error.", fg=typer.colors.YELLOW)
